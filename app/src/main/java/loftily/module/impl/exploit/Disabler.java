package loftily.module.impl.exploit;

import loftily.event.impl.packet.PacketReceiveEvent;
import loftily.event.impl.packet.PacketSendEvent;
import loftily.event.impl.player.motion.MotionEvent;
import loftily.event.impl.world.WorldLoadEvent;
import loftily.module.Module;
import loftily.module.ModuleCategory;
import loftily.module.ModuleInfo;
import loftily.utils.client.ClassUtils;
import loftily.utils.client.PacketUtils;
import loftily.utils.math.RandomUtils;
import loftily.utils.timer.DelayTimer;
import loftily.value.impl.MultiBooleanValue;
import loftily.value.impl.NumberValue;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.SPacketConfirmTransaction;
import net.minecraft.network.play.server.SPacketEntityVelocity;
import net.minecraft.network.play.server.SPacketExplosion;
import net.minecraft.util.EnumHand;

import java.util.LinkedList;
import java.util.Queue;

@ModuleInfo(name = "Disabler",category = ModuleCategory.EXPLOIT)
public class Disabler extends Module {

    private final MultiBooleanValue antiCheat = new MultiBooleanValue("BypassMode");

    private final NumberValue xzOffset = new NumberValue("XZOffset", 1024, -2048, 2048, 16).setVisible(() -> antiCheat.getValue("VoidTP"));
    private final NumberValue yOffset = new NumberValue("XZOffset", 1024, -2048, 2048, 16).setVisible(() -> antiCheat.getValue("VoidTP"));
    private final NumberValue teleportDelay = new NumberValue("TPDelay", 1, 1, 20, 1).setVisible(() -> antiCheat.getValue("VoidTP"));


    private final MultiBooleanValue clientPackets = new MultiBooleanValue("CPackets");
    private final MultiBooleanValue serverPackets = new MultiBooleanValue("SPackets");

    private final MultiBooleanValue packetBuffer = new MultiBooleanValue("Buffer");

    public final static Queue<Packet<?>> clientBuffer = new LinkedList<>();
    public final static Queue<Packet<?>> serverBuffer = new LinkedList<>();

    private short matrix123 = 0;
    private final DelayTimer fallFlyTimer = new DelayTimer();

    {
        ClassUtils.resolvePackage("net.minecraft.network.play.client").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("S")) return;

                    clientPackets.add(clazz.getSimpleName(), false);
                }
        );
        ClassUtils.resolvePackage("net.minecraft.network.play.server").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("S")) return;
                    serverPackets.add(clazz.getSimpleName(), false);
                }
        );

        antiCheat.add("NoGround", false)
                .add("SpoofGround", false)
                .add("InvalidKeepAlive", false)
                .add("VoidTP", false)
                .add("FallFlyingPacket", false)
                .add("MainHandPacket", false)
                .add("OffHandPacket", false)
                .add("VehicleMove",false)
                .add("MatrixSemi",false)
        ;
        antiCheat.write();

        packetBuffer.add("C03Buffer",false)
                .add("C00Buffer", false)
                .add("C0FBuffer",false)
                .add("S32Buffer",false)
                .add("S12Buffer",false)
                .add("S27Buffer",false);
    }

    @Override
    public void onDisable() {
        if(!clientBuffer.isEmpty()) {
            for (Packet<?> packet : clientBuffer) {
                PacketUtils.sendPacket(packet, false);
            }
        }
        if(!serverBuffer.isEmpty()) {
            for (Packet<?> packet : serverBuffer) {
                PacketUtils.receivePacket(packet, false);
            }
        }
        clientBuffer.clear();
        serverBuffer.clear();
        fallFlyTimer.reset();
    }

    @EventHandler
    public void onMotion(MotionEvent event) {
        antiCheat.getValue().forEach(
                (mode, value) -> {
                    if (value) {
                        switch (mode) {
                            case "MatrixSemi":
                                break;
                            case "VehicleMove":
                                PacketUtils.sendPacket(new CPacketVehicleMove(mc.player));
                                break;
                            case "OffHandPacket":
                                PacketUtils.sendPacket(new CPacketPlayerTryUseItem(EnumHand.OFF_HAND));
                                break;
                            case "MainHandPacket":
                                PacketUtils.sendPacket(new CPacketPlayerTryUseItem(EnumHand.MAIN_HAND));
                                break;
                            case "FallFlyingPacket":
                                if(fallFlyTimer.hasTimeElapsed(350)) {
                                    PacketUtils.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
                                    fallFlyTimer.reset();
                                }
                                break;
                            case "SpoofGround":
                                event.setOnGround(true);
                                break;
                            case "NoGround":
                                event.setOnGround(false);
                                break;
                            case "InvalidKeepAlive":
                                if (event.isPre()) {
                                    PacketUtils.sendPacket(new CPacketKeepAlive(RandomUtils.randomInt(-999999, 999999)), false);
                                }
                                break;
                            case "VoidTP":
                                if (mc.player.ticksExisted % teleportDelay.getValue() == 0) {
                                    event.setX(event.getX() + xzOffset.getValue());
                                    event.setY(event.getY() + yOffset.getValue());
                                    event.setZ(event.getZ() + xzOffset.getValue());
                                }
                                break;
                        }
                    }
                }
        );
    }

    @EventHandler
    public void onWorld(WorldLoadEvent event){
        clientBuffer.clear();
        serverBuffer.clear();
        fallFlyTimer.reset();
    }

    @EventHandler
    public void onCPacket(PacketSendEvent event) {
        Packet<?> packet = event.getPacket();
        clientPackets.getValue().forEach(
                (equalPacket,value)->{
                    if(packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if((packet instanceof CPacketPlayer && packetBuffer.getValue("C03Buffer"))
                || (packet instanceof CPacketConfirmTransaction && packetBuffer.getValue("C0FBuffer"))
                || (packet instanceof CPacketKeepAlive && packetBuffer.getValue("C00Buffer"))) {
            event.setCancelled(true);
            clientBuffer.add(packet);
        }
    }
    @EventHandler
    public void onSPacket(PacketReceiveEvent event) {
        Packet<?> packet = event.getPacket();
        serverPackets.getValue().forEach(
                (equalPacket,value)->{
                    if(packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if((packet instanceof SPacketConfirmTransaction && packetBuffer.getValue("S32Buffer"))
                || (packet instanceof SPacketEntityVelocity && packetBuffer.getValue("S12Buffer")
        || packet instanceof SPacketExplosion && packetBuffer.getValue("S27Buffer"))){
            event.setCancelled(true);
            serverBuffer.add(packet);
        }
        if(antiCheat.getValue("MatrixSemi")){
            if(packet instanceof SPacketConfirmTransaction){
                event.setCancelled(true);
                matrix123 = ((SPacketConfirmTransaction) packet).getActionNumber();
            }
            if(packet instanceof SPacketEntityVelocity) {
                if(((SPacketEntityVelocity) packet).getEntityID() == mc.player.getEntityId() && ((SPacketEntityVelocity) packet).getMotionY() / 8000f >= 0.21){
                    PacketUtils.sendPacket(new CPacketConfirmTransaction(1, matrix123,true),false);
                }
            }
        }
    }
}
