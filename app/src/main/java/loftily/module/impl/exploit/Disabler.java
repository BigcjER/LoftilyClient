package loftily.module.impl.exploit;

import loftily.event.impl.packet.PacketReceiveEvent;
import loftily.event.impl.packet.PacketSendEvent;
import loftily.module.Module;
import loftily.module.ModuleCategory;
import loftily.module.ModuleInfo;
import loftily.utils.client.ClassUtils;
import loftily.utils.client.PacketUtils;
import loftily.value.impl.BooleanValue;
import loftily.value.impl.MultiBooleanValue;
import loftily.value.impl.NumberValue;
import loftily.value.impl.mode.Mode;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTransaction;
import net.minecraft.network.play.client.CPacketKeepAlive;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketConfirmTransaction;
import net.minecraft.network.play.server.SPacketEntityVelocity;
import net.minecraft.network.play.server.SPacketExplosion;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

import java.util.LinkedList;
import java.util.Queue;

@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT)
public class Disabler extends Module {
    
    public final static Queue<Packet<?>> clientBuffer = new LinkedList<>();
    public final static Queue<Packet<?>> serverBuffer = new LinkedList<>();
    private final MultiBooleanValue clientPackets = new MultiBooleanValue("CPackets");
    private final MultiBooleanValue serverPackets = new MultiBooleanValue("SPackets");
    private final MultiBooleanValue packetBuffer = new MultiBooleanValue("Buffer");
    private final BooleanValue bufferAfterFlagging = new BooleanValue("BufferAfterFlagging", false);
    private final NumberValue flagTimes = new NumberValue("FlagTimes", 1, 1, 5).setVisible(bufferAfterFlagging::getValue);
    private int receivedFlagTimes = 0;
    
    {
        Mode[] modes = ClassUtils.getModes(getClass().getPackage().getName() + "." + "disablers");
        for (Mode mode : modes) {
            BooleanValue booleanValue = new BooleanValue(mode.getName(), false, this, mode);
            booleanValue.initMode();
            this.values.add(booleanValue);
        }
        
        packetBuffer.add("C03Buffer", false)
                .add("C00Buffer", false)
                .add("C0FBuffer", false)
                .add("S32Buffer", false)
                .add("S12Buffer", false)
                .add("S27Buffer", false);
        
        ClassUtils.resolvePackage("net.minecraft.network.play.client").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("C")) return;
                    
                    clientPackets.add(clazz.getSimpleName(), false);
                }
        );
        ClassUtils.resolvePackage("net.minecraft.network.play.server").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("S")) return;
                    serverPackets.add(clazz.getSimpleName(), false);
                }
        );
    }
    
    @EventHandler
    public void onSPacket(PacketReceiveEvent event) {
        Packet<?> packet = event.getPacket();
        if (packet instanceof SPacketPlayerPosLook) {
            receivedFlagTimes++;
        }
        serverPackets.getValue().forEach(
                (equalPacket, value) -> {
                    if (packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if ((packet instanceof SPacketConfirmTransaction && packetBuffer.getValue("S32Buffer"))
                || (packet instanceof SPacketEntityVelocity && packetBuffer.getValue("S12Buffer")
                || packet instanceof SPacketExplosion && packetBuffer.getValue("S27Buffer"))) {
            if (!bufferAfterFlagging.getValue() || receivedFlagTimes >= flagTimes.getValue()) {
                event.setCancelled(true);
                serverBuffer.add(packet);
            }
        }
    }
    
    @EventHandler
    public void onCPacket(PacketSendEvent event) {
        Packet<?> packet = event.getPacket();
        clientPackets.getValue().forEach(
                (equalPacket, value) -> {
                    if (packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if ((packet instanceof CPacketPlayer && packetBuffer.getValue("C03Buffer"))
                || (packet instanceof CPacketConfirmTransaction && packetBuffer.getValue("C0FBuffer"))
                || (packet instanceof CPacketKeepAlive && packetBuffer.getValue("C00Buffer"))) {
            if (!bufferAfterFlagging.getValue() || receivedFlagTimes >= flagTimes.getValue()) {
                event.setCancelled(true);
                clientBuffer.add(packet);
            }
        }
    }
    
    @Override
    public void onDisable() {
        if (!clientBuffer.isEmpty()) {
            for (Packet<?> packet : clientBuffer) {
                PacketUtils.sendPacket(packet, false);
            }
        }
        if (!serverBuffer.isEmpty()) {
            for (Packet<?> packet : serverBuffer) {
                PacketUtils.receivePacket(packet, false);
            }
        }
        clientBuffer.clear();
        serverBuffer.clear();
        receivedFlagTimes = 0;
    }
}
