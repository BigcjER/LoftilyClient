package loftily.module.impl.exploit;

import loftily.event.impl.packet.PacketReceiveEvent;
import loftily.event.impl.packet.PacketSendEvent;
import loftily.event.impl.player.RotationEvent;
import loftily.event.impl.player.motion.MotionEvent;
import loftily.event.impl.world.WorldLoadEvent;
import loftily.handlers.impl.RotationHandler;
import loftily.module.Module;
import loftily.module.ModuleCategory;
import loftily.module.ModuleInfo;
import loftily.utils.client.ClassUtils;
import loftily.utils.client.PacketUtils;
import loftily.utils.math.RandomUtils;
import loftily.utils.math.Rotation;
import loftily.utils.timer.DelayTimer;
import loftily.value.impl.BooleanValue;
import loftily.value.impl.MultiBooleanValue;
import loftily.value.impl.NumberValue;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.*;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

import java.util.LinkedList;
import java.util.Queue;

@ModuleInfo(name = "Disabler",category = ModuleCategory.EXPLOIT)
public class Disabler extends Module {

    private final MultiBooleanValue antiCheat = new MultiBooleanValue("BypassMode");

    private final NumberValue xzOffset = new NumberValue("XZOffset", 1024, -2048, 2048, 16).setVisible(() -> antiCheat.getValue("VoidTP"));
    private final NumberValue yOffset = new NumberValue("XZOffset", 1024, -2048, 2048, 16).setVisible(() -> antiCheat.getValue("VoidTP"));
    private final NumberValue teleportDelay = new NumberValue("TPDelay", 1, 1, 20, 1).setVisible(() -> antiCheat.getValue("VoidTP"));


    private final MultiBooleanValue clientPackets = new MultiBooleanValue("CPackets");
    private final MultiBooleanValue serverPackets = new MultiBooleanValue("SPackets");

    private final MultiBooleanValue packetBuffer = new MultiBooleanValue("Buffer");
    private final BooleanValue bufferAfterFlagging = new BooleanValue("BufferAfterFlagging",false);
    private final NumberValue flagTimes = new NumberValue("FlagTimes",1,1,5).setVisible(bufferAfterFlagging::getValue);

    public final static Queue<Packet<?>> clientBuffer = new LinkedList<>();
    public final static Queue<Packet<?>> serverBuffer = new LinkedList<>();

    private final DelayTimer fallFlyTimer = new DelayTimer();
    private int receivedFlagTimes = 0;
    private Rotation lastRotation = new Rotation(0,0);

    {
        ClassUtils.resolvePackage("net.minecraft.network.play.client").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("C")) return;

                    clientPackets.add(clazz.getSimpleName(), false);
                }
        );
        ClassUtils.resolvePackage("net.minecraft.network.play.server").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("S")) return;
                    serverPackets.add(clazz.getSimpleName(), false);
                }
        );

        antiCheat.add("NoGround", false)
                .add("SpoofGround", false)
                .add("InvalidKeepAlive", false)
                .add("VoidTP", false)
                .add("FallFlyingPacket", false)
                .add("MainHandPacket", false)
                .add("OffHandPacket", false)
                .add("VehicleMove",false)
                .add("C06=>C04",false)
                .add("NoRotation",false)
                .add("InputPacket", false)
        ;

        packetBuffer.add("C03Buffer",false)
                .add("C00Buffer", false)
                .add("C0FBuffer",false)
                .add("S32Buffer",false)
                .add("S12Buffer",false)
                .add("S27Buffer",false);

    }

    @Override
    public void onEnable(){
        lastRotation = RotationHandler.getRotation();
    }

    @Override
    public void onDisable() {
        if(!clientBuffer.isEmpty()) {
            for (Packet<?> packet : clientBuffer) {
                PacketUtils.sendPacket(packet, false);
            }
        }
        if(!serverBuffer.isEmpty()) {
            for (Packet<?> packet : serverBuffer) {
                PacketUtils.receivePacket(packet, false);
            }
        }
        clientBuffer.clear();
        serverBuffer.clear();
        fallFlyTimer.reset();
        receivedFlagTimes = 0;
    }

    @EventHandler(priority = -100)
    public void onRotation(RotationEvent event){
        if(antiCheat.getValue("NoRotation")){
            event.setRotation(lastRotation);
        }
    }

    @EventHandler
    public void onMotion(MotionEvent event) {
        antiCheat.getValue().forEach(
                (mode, value) -> {
                    if (value) {
                        switch (mode) {
                            case "InputPacket":
                                if(event.isPost()){
                                    PacketUtils.sendPacket(new CPacketInput(mc.player.moveStrafing,0.98f,mc.player.isJumping,mc.player.isSneaking()));
                                }
                                break;
                            case "VehicleMove":
                                PacketUtils.sendPacket(new CPacketVehicleMove(mc.player));
                                break;
                            case "OffHandPacket":
                                PacketUtils.sendPacket(new CPacketPlayerTryUseItem(EnumHand.OFF_HAND));
                                break;
                            case "MainHandPacket":
                                PacketUtils.sendPacket(new CPacketPlayerTryUseItem(EnumHand.MAIN_HAND));
                                break;
                            case "FallFlyingPacket":
                                if(fallFlyTimer.hasTimeElapsed(350)) {
                                    PacketUtils.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
                                    fallFlyTimer.reset();
                                }
                                break;
                            case "SpoofGround":
                                event.setOnGround(true);
                                break;
                            case "NoGround":
                                event.setOnGround(false);
                                break;
                            case "InvalidKeepAlive":
                                if (event.isPre()) {
                                    PacketUtils.sendPacket(new CPacketKeepAlive(RandomUtils.randomInt(-999999, 999999)), false);
                                }
                                break;
                            case "VoidTP":
                                if (mc.player.ticksExisted % teleportDelay.getValue() == 0) {
                                    event.setX(event.getX() + xzOffset.getValue());
                                    event.setY(event.getY() + yOffset.getValue());
                                    event.setZ(event.getZ() + xzOffset.getValue());
                                }
                                break;
                        }
                    }
                }
        );
    }

    @EventHandler
    public void onWorld(WorldLoadEvent event){
        clientBuffer.clear();
        serverBuffer.clear();
        fallFlyTimer.reset();
    }

    @EventHandler
    public void onCPacket(PacketSendEvent event) {
        Packet<?> packet = event.getPacket();
        clientPackets.getValue().forEach(
                (equalPacket,value)->{
                    if(packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if((packet instanceof CPacketPlayer && packetBuffer.getValue("C03Buffer"))
                || (packet instanceof CPacketConfirmTransaction && packetBuffer.getValue("C0FBuffer"))
                || (packet instanceof CPacketKeepAlive && packetBuffer.getValue("C00Buffer"))) {
            if(!bufferAfterFlagging.getValue() || receivedFlagTimes >= flagTimes.getValue()) {
                event.setCancelled(true);
                clientBuffer.add(packet);
            }
        }
        if(antiCheat.getValue("C06=>C04")){
            if(packet instanceof CPacketPlayer.PositionRotation) {
                event.setCancelled(true);
                PacketUtils.sendPacket(new CPacketPlayer.Position(((CPacketPlayer.PositionRotation) packet).x,
                        ((CPacketPlayer.PositionRotation) packet).y,
                        ((CPacketPlayer.PositionRotation) packet).z,
                        ((CPacketPlayer.PositionRotation) packet).onGround));
            }
        }

    }
    @EventHandler
    public void onSPacket(PacketReceiveEvent event) {
        Packet<?> packet = event.getPacket();
        if(packet instanceof SPacketPlayerPosLook){
            receivedFlagTimes += 1;
        }
        serverPackets.getValue().forEach(
                (equalPacket,value)->{
                    if(packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if((packet instanceof SPacketConfirmTransaction && packetBuffer.getValue("S32Buffer"))
                || (packet instanceof SPacketEntityVelocity && packetBuffer.getValue("S12Buffer")
        || packet instanceof SPacketExplosion && packetBuffer.getValue("S27Buffer"))){
            if(!bufferAfterFlagging.getValue() || receivedFlagTimes >= flagTimes.getValue()) {
                event.setCancelled(true);
                serverBuffer.add(packet);
            }
        }
    }
}
