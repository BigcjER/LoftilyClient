package loftily.module.impl.exploit;

import loftily.event.impl.packet.PacketReceiveEvent;
import loftily.event.impl.packet.PacketSendEvent;
import loftily.event.impl.player.motion.MotionEvent;
import loftily.module.Module;
import loftily.module.ModuleCategory;
import loftily.module.ModuleInfo;
import loftily.utils.client.ClassUtils;
import loftily.utils.client.PacketUtils;
import loftily.utils.math.RandomUtils;
import loftily.value.impl.MultiBooleanValue;
import loftily.value.impl.NumberValue;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTransaction;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketKeepAlive;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketConfirmTransaction;
import net.minecraft.network.play.server.SPacketEntityVelocity;
import net.minecraft.network.play.server.SPacketExplosion;

import java.util.LinkedList;
import java.util.Queue;

@ModuleInfo(name = "Disabler",category = ModuleCategory.EXPLOIT)
public class Disabler extends Module {

    private final MultiBooleanValue antiCheat = new MultiBooleanValue("AntiCheats")
            .add("NoGround", false)
            .add("SpoofGround", false)
            .add("InvalidKeepAlive", false)
            .add("VoidTP", false)
            .add("FallFlyingPacket", false);

    private final NumberValue xzOffset = new NumberValue("XZOffset", 1024, -2048, 2048, 16).setVisible(() -> antiCheat.getValue("VoidTP"));
    private final NumberValue yOffset = new NumberValue("XZOffset", 1024, -2048, 2048, 16).setVisible(() -> antiCheat.getValue("VoidTP"));
    private final NumberValue teleportDelay = new NumberValue("TPDelay", 1, 1, 20, 1).setVisible(() -> antiCheat.getValue("VoidTP"));


    private final MultiBooleanValue clientPackets = new MultiBooleanValue("CPackets");
    private final MultiBooleanValue serverPackets = new MultiBooleanValue("SPackets");

    private final MultiBooleanValue packetBuffer = new MultiBooleanValue("Buffer")
            .add("C03Buffer",false)
            .add("C00Buffer", false)
            .add("C0FBuffer",false)
            .add("S32Buffer",false)
            .add("S12Buffer",false)
            .add("S27Buffer",false);

    public final static Queue<Packet<?>> clientBuffer = new LinkedList<>();
    public final static Queue<Packet<?>> serverBuffer = new LinkedList<>();


    {
        ClassUtils.resolvePackage("net.minecraft.network.play.client").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("S")) return;

                    clientPackets.add(clazz.getSimpleName(), false);
                }
        );
        ClassUtils.resolvePackage("net.minecraft.network.play.server").forEach(
                clazz -> {
                    String name = clazz.getSimpleName();
                    if (!name.startsWith("S")) return;
                    serverPackets.add(clazz.getSimpleName(), false);
                }
        );
    }

    @Override
    public void onDisable() {
        if(!clientBuffer.isEmpty()) {
            for (Packet<?> packet : clientBuffer) {
                PacketUtils.sendPacket(packet, false);
            }
        }
        if(!serverBuffer.isEmpty()) {
            for (Packet<?> packet : serverBuffer) {
                PacketUtils.receivePacket(packet, false);
            }
        }
        clientBuffer.clear();
        serverBuffer.clear();
    }

    @EventHandler
    public void onMotion(MotionEvent event) {
        antiCheat.getValue().forEach(
                (mode, value) -> {
                    if (value) {
                        switch (mode) {
                            case "FallFlyingPacket":
                                if(mc.player.ticksExisted % 3 == 0) {
                                    PacketUtils.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
                                }
                                break;
                            case "SpoofGround":
                                event.setOnGround(true);
                                break;
                            case "NoGround":
                                event.setOnGround(false);
                                break;
                            case "InvalidKeepAlive":
                                if (event.isPre()) {
                                    PacketUtils.sendPacket(new CPacketKeepAlive(RandomUtils.randomInt(-999999, 999999)), false);
                                }
                                break;
                            case "VoidTP":
                                if (mc.player.ticksExisted % teleportDelay.getValue() == 0) {
                                    event.setX(event.getX() + xzOffset.getValue());
                                    event.setY(event.getY() + yOffset.getValue());
                                    event.setZ(event.getZ() + xzOffset.getValue());
                                }
                                break;
                        }
                    }
                }
        );
    }

    @EventHandler
    public void onCPacket(PacketSendEvent event) {
        Packet<?> packet = event.getPacket();
        clientPackets.getValue().forEach(
                (equalPacket,value)->{
                    if(packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if((packet instanceof CPacketPlayer && packetBuffer.getValue("C03Buffer"))
                || (packet instanceof CPacketConfirmTransaction && packetBuffer.getValue("C0FBuffer"))
                || (packet instanceof CPacketKeepAlive && packetBuffer.getValue("C00Buffer"))) {
            event.setCancelled(true);
            clientBuffer.add(packet);
        }
    }
    @EventHandler
    public void onSPacket(PacketReceiveEvent event) {
        Packet<?> packet = event.getPacket();
        serverPackets.getValue().forEach(
                (equalPacket,value)->{
                    if(packet.getClass().getSimpleName().equals(equalPacket) && value) {
                        event.setCancelled(true);
                    }
                }
        );
        if((packet instanceof SPacketConfirmTransaction && packetBuffer.getValue("S32Buffer"))
                || (packet instanceof SPacketEntityVelocity && packetBuffer.getValue("S12Buffer")
        || packet instanceof SPacketExplosion && packetBuffer.getValue("S27Buffer"))){
            event.setCancelled(true);
            serverBuffer.add(packet);
        }
    }
}
