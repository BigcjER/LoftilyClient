package loftily.module.impl.exploit;

import loftily.event.impl.packet.PacketSendEvent;
import loftily.handlers.impl.player.CombatHandler;
import loftily.module.Module;
import loftily.module.ModuleCategory;
import loftily.module.ModuleInfo;
import loftily.utils.client.PacketUtils;
import loftily.value.impl.BooleanValue;
import loftily.value.impl.NumberValue;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTransaction;
import net.minecraft.network.play.client.CPacketKeepAlive;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

@ModuleInfo(name = "PingSpoof",category = ModuleCategory.EXPLOIT)
public class PingSpoof extends Module {
    private final NumberValue delay = new NumberValue("Delay", 25000, 0, 99999, 10);
    private final BooleanValue attackCancel = new BooleanValue("CancelOnAttack", true);
    private final AtomicLong key = new AtomicLong(-1);
    private final AtomicInteger uid = new AtomicInteger(-1);
    private final AtomicInteger windowId = new AtomicInteger(-1);
    private ScheduledExecutorService scheduler;
    
    @Override
    public void onEnable() {
        scheduler = Executors.newSingleThreadScheduledExecutor();
    }
    
    @Override
    public void onDisable() {
        if (scheduler != null) {
            scheduler.shutdownNow();
            
        }
    }
    
    @EventHandler
    public void onPacket(PacketSendEvent event) {
        if (mc.player == null || mc.getConnection() == null || mc.isSingleplayer()) return;
        
        if (attackCancel.getValue() && CombatHandler.inCombat) return;
        
        if (scheduler == null) {
            scheduler = Executors.newSingleThreadScheduledExecutor();
        }
        
        Packet<?> packet = event.getPacket();
        
        if (packet instanceof CPacketConfirmTransaction) {
            final CPacketConfirmTransaction c0f = (CPacketConfirmTransaction) packet;
            if (c0f.getUid() == this.uid.get() && c0f.getWindowId() == this.windowId.get()) return;
            
            event.setCancelled(true);
            scheduler.schedule(() -> {
                this.uid.set(c0f.getUid());
                this.windowId.set(c0f.getWindowId());
                
                mc.addScheduledTask(() -> PacketUtils.sendPacket(packet));
            }, delay.getValue().longValue(), TimeUnit.MILLISECONDS);
        }
        
        if (packet instanceof CPacketKeepAlive) {
            CPacketKeepAlive c00 = (CPacketKeepAlive) packet;
            if (c00.getKey() == this.key.get()) return;
            
            event.setCancelled(true);
            scheduler.schedule(() -> {
                this.key.set(c00.getKey());
                
                mc.addScheduledTask(() -> PacketUtils.sendPacket(packet));
            }, delay.getValue().longValue(), TimeUnit.MILLISECONDS);
        }
    }
}
