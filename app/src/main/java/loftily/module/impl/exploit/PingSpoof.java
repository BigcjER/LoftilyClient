package loftily.module.impl.exploit;

import loftily.event.impl.packet.PacketSendEvent;
import loftily.event.impl.player.AttackEvent;
import loftily.event.impl.world.UpdateEvent;
import loftily.module.Module;
import loftily.module.ModuleCategory;
import loftily.module.ModuleInfo;
import loftily.value.impl.BooleanValue;
import loftily.value.impl.NumberValue;
import loftily.value.impl.mode.ModeValue;
import loftily.value.impl.mode.StringMode;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketClientStatus;
import net.minecraft.network.play.client.CPacketConfirmTransaction;
import net.minecraft.network.play.client.CPacketKeepAlive;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

@ModuleInfo(name = "PingSpoof",category = ModuleCategory.EXPLOIT)
public class PingSpoof extends Module {
    private final ModeValue modeValue = new ModeValue("Mode","Old",this,new StringMode("Old"),
            new StringMode("New"));
    private final NumberValue delay = new NumberValue("Delay",5000,0,99999);
    private final BooleanValue attackCancel = new BooleanValue("AttackCancel",true);

    private final Map<Packet<?>, Long> packetQueue = new HashMap<>();

    private long key;
    private short uid;
    private int windowId;
    private boolean attacked = false;

    @Override
    public void onDisable() {
        synchronized (packetQueue) {
            packetQueue.clear();
        }
        attacked = false;
    }

    @EventHandler
    public void onAttack(AttackEvent event){
        attacked = true;
    }

    @EventHandler
    public void onPacket(PacketSendEvent event) {
        if (mc.player == null || mc.getConnection() == null) {
            return;
        }

        final Packet<?> packet = event.getPacket();
        final String mode = modeValue.getValueByName();

        if(attackCancel.getValue() && attacked && packet instanceof  CPacketConfirmTransaction){
            attacked = false;
            return;
        }

        if (mode.equalsIgnoreCase("New")) {
            if ((packet instanceof CPacketKeepAlive || packet instanceof CPacketConfirmTransaction || packet instanceof CPacketClientStatus)
                    && !mc.player.isDead && mc.player.getHealth() > 0) {

                event.setCancelled(true);

                synchronized (packetQueue) {
                    packetQueue.put(packet, System.currentTimeMillis() + delay.getValue().intValue());
                }
            }
        } else if (mode.equalsIgnoreCase("Old")) {
            if (packet instanceof CPacketConfirmTransaction) {
                final CPacketConfirmTransaction c0f = (CPacketConfirmTransaction) packet;

                if (c0f.getUid() == this.uid && c0f.getWindowId() == this.windowId) {
                    return;
                }

                event.setCancelled(true);
                new Thread(() -> {
                    try {
                        Thread.sleep(delay.getValue().intValue());
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        e.printStackTrace();
                    }
                    this.uid = c0f.getUid();
                    this.windowId = c0f.getWindowId();
                    mc.getConnection().sendPacket(packet);
                }).start();
            }

            if (packet instanceof CPacketKeepAlive) {
                final CPacketKeepAlive c00 = (CPacketKeepAlive) packet;

                if (c00.getKey() == this.key) {
                    return;
                }

                event.setCancelled(true);
                new Thread(() -> {
                    try {
                        Thread.sleep(delay.getValue().intValue());
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        e.printStackTrace();
                    }
                    this.key = c00.getKey();
                    mc.getConnection().sendPacket(packet);
                }).start();
            }
        }
    }

    @EventHandler
    public void onUpdate(UpdateEvent event) {
        if (!modeValue.is("New")) {
            return;
        }

        if (mc.player == null || mc.getConnection() == null) {
            synchronized (packetQueue) {
                packetQueue.clear();
            }
            return;
        }

        final long currentTime = System.currentTimeMillis();

        synchronized (packetQueue) {
            Iterator<Map.Entry<Packet<?>, Long>> iterator = packetQueue.entrySet().iterator();

            while (iterator.hasNext()) {
                Map.Entry<Packet<?>, Long> entry = iterator.next();
                if (entry.getValue() <= currentTime) {
                    mc.getConnection().sendPacket(entry.getKey());
                    iterator.remove();
                }
            }
        }
    }
}
