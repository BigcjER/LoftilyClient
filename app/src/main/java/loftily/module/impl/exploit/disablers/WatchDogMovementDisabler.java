package loftily.module.impl.exploit.disablers;

import loftily.event.impl.client.MoveInputEvent;
import loftily.event.impl.player.motion.MotionEvent;
import loftily.event.impl.render.Render2DEvent;
import loftily.event.impl.world.WorldLoadEvent;
import loftily.handlers.impl.player.RotationHandler;
import loftily.module.impl.exploit.Disabler;
import loftily.utils.ServerUtils;
import loftily.utils.client.MessageUtils;
import loftily.utils.math.Rotation;
import loftily.utils.player.PlayerUtils;
import loftily.utils.render.Colors;
import loftily.utils.render.RenderUtils;
import loftily.value.impl.NumberValue;
import loftily.value.impl.mode.Mode;
import net.lenni0451.lambdaevents.EventHandler;
import net.minecraft.client.gui.ScaledResolution;

public class WatchDogMovementDisabler extends Mode<Disabler> {
    public static boolean disablerLoaded;
    private final NumberValue disablerTicks = new NumberValue("WatchDogMovement-Ticks", 100.0, 85.0, 150.0, 5.0);
    private final NumberValue activationDelay = new NumberValue("WatchDogMovement-ActivationDelay(seconds)", 0.0, 0.0, 4.0, 0.5);
    private final float barWidth = 60.0F;
    public boolean running;
    int tickCounter = 0;
    boolean waitingForGround = false;
    boolean applyingMotion = false;
    int stateTickCounter = 0;
    boolean warningDisplayed = false;
    int sprintToggleTick = 0;
    boolean shouldRun = false;
    long lobbyTime = 0L;
    long finished = 0L;
    long activationDelayMillis;
    private float filledWidth;
    private float barX;
    private float barY;
    private boolean shouldRender;
    private double firstY;
    private boolean reset;
    private float savedPitch;
    private boolean worldJoin;
    private int wDelay;
    
    public WatchDogMovementDisabler() {
        super("WatchDogMovement");
    }
    
    @Override
    public void onEnable() {
        if (!disablerLoaded) {
            this.resetState();
        }
    }
    
    @Override
    public void onDisable() {
        this.shouldRun = false;
        this.running = false;
    }
    
    private void resetState() {
        this.savedPitch = mc.player.rotationPitch;
        this.shouldRun = true;
        this.tickCounter = 0;
        this.applyingMotion = false;
        this.waitingForGround = true;
        this.stateTickCounter = 0;
        this.warningDisplayed = false;
        this.running = false;
        this.sprintToggleTick = 0;
        this.lobbyTime = System.currentTimeMillis();
        this.finished = 0L;
        this.shouldRender = false;
        this.reset = false;
        this.worldJoin = false;
        this.activationDelayMillis = (long) (this.activationDelay.getValue() * 1000.0);
    }
    
    @EventHandler
    public void onWorld(WorldLoadEvent event) {
        this.resetState();
    }
    
    @EventHandler
    public void onMoveInput(MoveInputEvent e) {
        if (this.running && !ServerUtils.isReplay() && !ServerUtils.spectatorCheck()) {
            e.setForward(0.0F);
            e.setStrafe(0.0F);
            mc.player.movementInput.jump = false;
        }
    }
    
    @EventHandler
    public void onRenderTick(Render2DEvent ev) {
        if (PlayerUtils.nullCheck()) {
            if (mc.currentScreen == null && this.shouldRun && this.shouldRender) {
                float barHeight = 4.0F;
                RenderUtils.drawRoundedRect(this.barX, this.barY, this.barWidth, barHeight, 3.0F, Colors.BackGround.color);
                RenderUtils.drawRoundedRect(this.barX, this.barY, this.filledWidth, barHeight, 3.0F, Colors.Active.color);
            }
        }
    }
    
    @EventHandler
    public void onMotion(MotionEvent event) {
        if (event.isPost()) return;
/*                                if (this.resetDisabler.isToggled()) {
                                    Utils.modulePrint("&7[&dR&7] &cdisabler resetting...");
                                    this.resetState();
                                    this.disablerLoaded = false;
                                    this.resetDisabler.disable();
                                }*/
        
        if (ServerUtils.getLobbyStatus() != 1 && ServerUtils.hypixelStatus() == 1 && !ServerUtils.isReplay()) {
            long now = System.currentTimeMillis();
            if (this.finished != 0L && mc.player.onGround && now - this.finished > 4000L) {
                MessageUtils.clientMessageWithWaterMark("disabler enabled");
                this.finished = 0L;
                this.filledWidth = 0.0F;
                disablerLoaded = true;
            }
            
            if (this.shouldRun) {
                if (now - this.lobbyTime >= this.activationDelayMillis) {
                    this.running = true;
                    RotationHandler.setClientRotation(new Rotation(0.0F, this.savedPitch), 1, 1, RotationHandler.MoveFix.NONE);
                    if (this.waitingForGround) {
                        if (mc.player.onGround) {
                            mc.player.motionY = 0.42F;
                            this.waitingForGround = false;
                            this.worldJoin = false;
                        }
                    } else {
                        if (mc.player.offGroundTicks >= 10 || this.worldJoin && ++this.wDelay >= 3) {
                            if (!this.applyingMotion) {
                                this.applyingMotion = true;
                                this.firstY = mc.player.posY;
                            }
                            
                            if (this.tickCounter < this.disablerTicks.getValue()) {
                                this.shouldRender = true;
                                mc.player.motionX = 0.0;
                                mc.player.motionY = 0.0;
                                mc.player.motionZ = 0.0;
                                if (mc.player.posY != this.firstY) {
                                    if (!this.reset) {
                                        this.resetState();
                                        this.activationDelayMillis = 2000L;
                                        this.reset = true;
                                        MessageUtils.clientMessageWithWaterMark("disabler reset, wait 2s");
                                    } else {
                                        this.shouldRun = false;
                                        this.applyingMotion = false;
                                        this.running = false;
                                        MessageUtils.clientMessageWithWaterMark("failed to reset disabler, re-enable to try again");
                                    }
                                }
                                
                                if (mc.player.ticksExisted % 2 == 0) {
                                    event.setZ(event.getZ() + 0.075);
                                    event.setX(event.getX() + 0.075);
                                }
                                
                                this.tickCounter++;
                            } else if (!this.warningDisplayed) {
                                this.warningDisplayed = true;
                                this.finished = now;
                                this.shouldRender = false;
                                this.shouldRun = false;
                                this.applyingMotion = false;
                                this.running = false;
                            }
                        }
                        
                        this.filledWidth = (float) (this.barWidth * this.tickCounter / this.disablerTicks.getValue());
                        ScaledResolution scaledResolution = new ScaledResolution(mc);
                        int[] disp = new int[]{scaledResolution.getScaledWidth(), scaledResolution.getScaledHeight(), scaledResolution.getScaleFactor()};
                        this.barX = disp[0] / 2F - this.barWidth / 2.0F;
                        this.barY = disp[1] / 2F + 12;
                    }
                }
            }
        }
    }
}
